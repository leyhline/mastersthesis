\newcommand{\blame}{\text{ \textbf{blame} }}
\newcommand{\Single}{\text{ \textbf{S}}}

\chapter{Cast Calculus}\label{chap:cast-calculus}

The \emph{Cast Calculus Label Dependent Lambda Calculus} is an extension to regular LDLC as introduced in section~\ref{sec:ldlc}. It adds an explicit cast between two types, a dynamic type $\star$ as well as related language constructs. CCLDLC is but an intermediate representation between LDLC and a gradual typing extension. Internally, casts at runtime involving the dynamic type must happen explicitly. With gradual typing these type casts are hidden, hence a translation to the cast calculus is necessary.

\section{Exptessions and Types}\label{sec:cc-expressions}

\begin{figure}
\begin{align*}
 M ::= & \enspace \dots \enspace|\enspace
     M : A \Rightarrow B \enspace|\enspace \blame \\
 A ::= & \enspace \dots \enspace|\enspace
     \star \enspace|\enspace \bot \enspace|\enspace \top
\end{align*}
\caption{Extensions to LDLC for CCLDLC for expression $M$ and types $A, A', B, B'$.}
\label{fig:ccldlc-extensions}
\end{figure}

CCLDLC adds the cast and blame expression as well as the dynamic type, top type and bottom type; see figure~\ref{fig:ccldlc-extensions}.
The bottom type's single purpose is as type for the blame expression $(\blame : \bot)$. The top type is only used for unfolding the bottom type, evaluating $\bot$ to a function of any argument $\Pi(y:\top)\bot$, the \emph{smallest function type}. Every type $A$ is a subtype of $\top$ ($A \leq \top$) and $\bot$ is a subtype of every type $B$ ($\bot \leq B$). Hence, the smallest function type describes a function accepting any argument, always evaluating to \blame.

\section{Values}

\begin{figure}
\begin{align*}
 V ::= & \enspace \dots \enspace
        |\enspace (V : G \Rightarrow \star) & \text{dynamic wrapper}\\
      & |\enspace (\rho, \lambda(x:A)M) & \text{closure} \\
      & |\enspace (V : (\rho, \Pi(x:A) A') \Rightarrow (\rho, \Pi(x:B) B') ) \\
 G ::= & \Unit \enspace|\enspace
    L \enspace|\enspace
    \Single\{V: \Unit\} \enspace|\enspace
    \Single\{V: L\} \\
    & |\enspace
    \Pi(x:\star)\star \enspace|\enspace
    \Sigma(x:\star)\star \\
 \rho ::= & \enspace \cdot \enspace|\enspace \rho, x = V
\end{align*}
\caption{Values $V$ and ground types $G$ in CCLDLC with environment $\rho$ and variable $x$.}
\label{fig:ccldlc-extensions-values}
\end{figure}

Values are extended in a less intuitive way, see figure~\ref{fig:ccldlc-extensions-values}. First, there is a \emph{dynamic wrapper}, casting a value $V$ from a ground type $G$ to the dynamic type $\star$. The whole cast term is a value itself. A ground type indicates an application of dynamic arguments to a top level type constructor as well as subtyping capabilities. Hence, label types are ground types, together with the unit type and corresponding singleton types. There are also ground types for function types $\Pi$ where argument and return type are unknown and for pair types $\Sigma$ with unknown component types.\footnote{Here, an ``unknown type'' means unknown at runtime, thus we use the dynamic type $\star$.}

Next, a function closure where the evaluation environment $\rho$ is explicitly part of the value.

And finally a function type cast for value $V$ of a specific function type to another one. \todo{Why is this necessary?}

\section{Type Inference Rules / Evaluation Rules}\label{sec:ccldlc-inference-rules}

We now introduce additional evaluation rules, especially for the cast expression. Such a \emph{cast reduction} is written $(V : A^\circ : B^\circ) \Downarrow V'$, and turns a value $V$ of type $A^\circ$ into value $V'$ of type $B^\circ$. In contrast, when the evaluation reaches \blame, it simply fails. This failure needs to be handled by the implementation. The whole set cast reduction rules is listed in figure~\ref{fig:cast-reduction-rules}.

\begin{figure}
\begin{mathpar}
\inferrule[Cast-Reduce]
 {\rho \vdash M \downarrow V \and
 \rho \vdash' A \downarrow A^\circ \and
 \rho \vdash' B \downarrow B^\circ \and
 (V : A^\circ \Rightarrow B^\circ) \Downarrow V'}
 {\rho \vdash (M : A \Rightarrow B) \Downarrow V'}
\\
\inferrule[Cast-Is-Value]
 {V = (V' : A^\circ \Rightarrow B^\circ)}
 {V \Downarrow V}
\and
\inferrule[Cast-Dyn-Dyn]
 {A^\circ \leq \star}
 {(V : A^\circ \Rightarrow \star) \Downarrow V}
\\
\inferrule[Cast-Sub]
 {G \leq H}
 {(V : G \Rightarrow H) \Downarrow V}
\and
\inferrule[Cast-Fail]
 {A^\circ \rhd G \and B^\circ \rhd H \and G \nleq H}
 {(V : A^\circ \Rightarrow B^\circ) \Downarrow \blame}
\\
 \inferrule[Cast-Bot]
 {}
 {(V : A^\circ \Rightarrow \bot) \Downarrow \blame}
\\
\inferrule[Cast-Collapse]
 {G \leq H}
 {((V : G \Rightarrow \star) : \star \Rightarrow H) \Downarrow V}
\and
\inferrule[Cast-Collide]
 {G \nleq H}
 {((V : G \Rightarrow \star) : \star \Rightarrow H) \Downarrow \blame}
\\
\inferrule[Cast-Factor-Left]
 {A^\circ \rhd G \and A^\circ \neq G \\\\
  (V:A^\circ \Rightarrow G) \Downarrow V'}
 {(V : A^\circ \Rightarrow \star) \Downarrow (V' : G \Rightarrow \star)}
\and
\inferrule[Cast-Factor-Right]
 {B^\circ \rhd H \and B^\circ \neq H \\\\
  (V : \star \Rightarrow H) \Downarrow V' \\\\
  (V' : H \Rightarrow B^\circ) \Downarrow V''}
 {(V : \star \Rightarrow B^\circ) \Downarrow V''}
\\
\inferrule[Cast-Pair]
 {\rho \vdash' A \downarrow A^\circ \and \rho' \vdash' A' \downarrow A'^\circ \and
  (V : A^\circ \Rightarrow A'^\circ) \Downarrow V' \\
  \rho,x=V \vdash' B \downarrow B^\circ \and \rho',x=V' \vdash' B' \downarrow B'^\circ \and (W:B^\circ \Rightarrow B'^\circ) = W' \\
 }
 {(\langle V,W \rangle : (\rho, \Sigma(x:A)B) \Rightarrow (\rho', \Sigma(x:A')B')) \Downarrow \langle V', W' \rangle}
\\
\inferrule[Cast-Function]
 {\rho_\circ \vdash M \downarrow (V : (\rho, \Pi(x:A)B) \Rightarrow (\rho',\Pi(x:A')B')) \and \rho_\circ \vdash N \downarrow W' \\
  \rho \vdash' A \downarrow A^\circ \and \rho' \vdash' A' \downarrow A'^\circ \and (W' : A'^\circ \Rightarrow A^\circ) \Downarrow W \\
  \rho',x=W' \vdash' B' \downarrow B'^\circ \and \rho,x=W \vdash' B \downarrow B^\circ \\
  \rho_\circ \vdash (V W : B^\circ \Rightarrow B'^\circ) \downarrow U'}
 {\rho_\circ \vdash M N \downarrow U'}
\end{mathpar}
\caption{Rules for cast reduction ($\Downarrow$) in CCLDLC.}
\label{fig:cast-reduction-rules}
\end{figure}

In figure~\ref{fig:ccldlc-extensions}, the cast expression $(M : A \Rightarrow B)$ consists of an expression $M$ of type $A$ and a target type $B$. The \textsc{Cast-Reduce} rule describes proceed: In environment $\rho$, the given expression is evaluated ($M \downarrow V$) resulting in a value. As for the types $A$ and $B$, we need to evaluate them into \emph{head normal form} ($A \downarrow A^\circ$; $B \downarrow B^\circ$).

\renewcommand{\mkcitation}[1]{\\--- #1}
\begin{displayquote}[\cite{peytonjones1987the}]
A lambda expression in in \emph{head normal form} (HNF) if and only if it is of the form
\begin{equation*}
\lambda x_1 . \lambda x_2 \dots \lambda x_n . (v~M_1~M_2~\dots~M_m)
\end{equation*}
where $n, m \geq 0$; \\
\hspace*{11mm}$v$ is a variable ($x_i$), a data object, for a built-in function; \\
and \hspace*{2mm} $(v~M_1~M_2~\dots~M_p)$ is not a redex for any $p \leq m$.
\end{displayquote}

The types of CCLDLC evaluate to one of the following HNF types:

\begin{equation}
\begin{split}
 A^\circ ::= \bot ~|~ \star ~|~ \Unit ~|~ L ~|~ \Single\{V:A^\circ\} \\
 |~ (\rho, \Pi(x:A)B) ~|~ (\rho, \Sigma(x:A)B)
\end{split}
 \end{equation}

\todo{Is this really head normal form? Or weak head normal form?}

After evaluating the components of the cast expression, the actual cast reduction is invoked.
