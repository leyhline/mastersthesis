\chapter{Introduction}\label{chap:introduction}

In programming, dependent types are the next step in the unification of language constructs. Not only values and functions but also types are first class constructs. This goes along with practical advantages: Types may now depend on values, allowing for more precise typing, consequently better correctness guarantees and more expressive power when describing programs. Nevertheless, such power comes at a cost: As the difference between proof and program grows hazy, typechecking and program interpretation will face similar problems. The former becomes more costly and might be subject to the halting problem.

\section{Label Dependent Types}

Over the years, different approaches to dependent types surfaced. This work is bases on a subset of ``Label Dependent Session Types'' by \cite{thiemann2019}. Ignoring session types, we focus on the \emph{Label Dependent Lambda Calculus} (LDLC), extending it during this work. In general, types in LDLC refer to finite sets of label values. For example, it is easy to define type \textbf{Bool} with two labels representing \emph{True} and \emph{False} respectively:

\begin{equation}\label{eqn:bool}
\Bool    := \{\ell_{True}, \ell_{False}\}
\end{equation}

Elimination is done using a \textbf{case} construct, matching labels with expressions. In equation~\ref{eqn:ldlc}, the type of variable $y$ depends on the boolean $x$. This quickly results in unwieldy type annotations.

\begin{equation}\label{eqn:ldlc}
\begin{split}
&\lambda (x: \Bool) \\
&\quad . \lambda (y: \case x \{\ell_T: \Int, \ell_F: \Bool\} ) \\
&\qquad . \case x \{\ell_T: 17+y,\ell_F: \notf y\} \\
: & \Pi(x : \Bool) \\
&\quad . \Pi (y: \case x \{\ell_T: \Int, \ell_F: \Bool\} ) \\
&\qquad . \case x \{\ell_T: \Int, \ell_F: \Bool \}
\end{split}
\end{equation}

Label-dependency has many advantages. It is less complex than full value-dependency. The compiler has more options to check type safety, resulting in a more reliable program. Furthermore, types can serve as a machine-readable and machine-verifiable documentation since they give hints about the workings of the code.
As a disadvantage, the code above is quite verbose. Adding all these type annotations can be cumbersome for a programmer, especially when still exploring a given task and trying out different approaches.

\section{Gradual Typing}

\emph{Gradual Typing} mitigates this problem since it allows to mix static and dynamic typing. In their paper, \cite{fu2021} propose an extension, the \emph{Gradual Label Dependent Lambda Calculus} (GLDLC), introducing the dynamic type $\star$. Annotating terms with $\star$ results in type checking at runtime, still preserving the guarantees of statically typed code at its boundaries. One possibility for rewriting equation~\ref{eqn:ldlc} is:

\begin{equation}\label{eqn:gldlc}
\begin{split}
&\lambda (x: \Bool)
. \lambda (y: \ast)
. \case x \{\ell_T: 17+y,\ell_F: \notf y\} \\
: & \Pi(x : \Bool)
. \Pi (y: \ast)
. \case x \{\ell_T: \Int, \ell_F: \Bool \}
\end{split}
\end{equation}

The original paper list more advantages and applications of GLDLC, whereas this work focuses on implementation aspects. Therefore, the methods used for evaluating type $\star$ are of interest, which leads us to an intermediate representation, describing the cast from arbitrary type $A$ to $\star$ and from $\star$ to an arbitrary type $B$. These cast are part of the \emph{Cast Calculus Label Dependent Lambda Calculus} (CCLDLC). The \emph{Cast Calculus} adds an explicit type cast expression ``$x : A \Rightarrow B$'', casting the value of $x$ of type $A$ to type $B$. Naturally, type $\star$ can occur on both sides. Rewriting equation~\ref{eqn:gldlc} results in a more verbose and more explicit formulation:

\begin{equation}\label{eqn:ccldlc}
\begin{split}
&\lambda (x: \Bool) . \lambda (y: \star ) \\
&\quad . \case x \{\ell_T: 17+(y:\star \Rightarrow \Int),\ell_F: \notf (y:\star \Rightarrow \Bool)\} \\
: & \Pi(x : \Bool) . \Pi (y: \star ) \\
&\quad . \case x \{\ell_T: \Int, \ell_F: \Bool \}
\end{split}
\end{equation}

We contribute an implementation of CCLDLC by extending LDGV, an existing interpreter for Label Dependent Session Types in the Haskell programming language.
\\
The full source code is available at \url{https://github.com/leyhline/ldgv/}.

First, we describe the \emph{Label Dependent Lambda Calculus}, its rules and its compiler since this provides the foundation for our extensions. Next, there in an outline of the program's structure with respect to changes we made. Then, we formally describe the rules for CCLDLC. Finally, we document the implementation in a detailed manner.

\section{Notation}

Since this work is about building an implementation, there needs to be a distinction between concepts and code. Often, both will be quite similar. Concepts like formulas and rules are conveyed using mathematical notation. This is not necessarily identical to the actual syntax of LDGV.

\begin{align*}
 x &:= \ell_{foo} & \text{variable definition} \\
 A &:= \{ \ell_{foo} \} & \text{type definition}
\end{align*}

Then again, actual code precisely reflects the capabilities of LDGV. One can feed it verbatim to the interpreter. It is written in a monospaced font.

\begin{lstlisting}[language=ldgv,caption=Code listing example]
val x = 'foo
type A : ~un = { 'foo }
\end{lstlisting}
