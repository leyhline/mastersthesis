\newcommand{\letb}{\text{ \textbf{let} }}
\newcommand{\inb}{\text{ \textbf{in} }}
\newcommand{\rec}{\text{ \textbf{rec} }}
\newcommand{\natrec}{\text{ \textbf{natrec} }}
\newcommand{\fstb}{\text{ \textbf{fst} }}
\newcommand{\sndb}{\text{ \textbf{snd} }}

\newcommand{\Unit}{\text{ \textbf{Unit} }}
\newcommand{\Nat}{\text{ \textbf{Nat} }}
\newcommand{\Double}{\text{ \textbf{Double} }}
\newcommand{\Bot}{\text{ \textbf{Bot} }}

\newcommand{\valb}{\text{ \textbf{val} }}
\newcommand{\typeb}{\text{ \textbf{type} }}

\chapter{Foundations}\label{chap:foundations}

Before diving into the \emph{Cast Calculus} we introduce the foundation, the \emph{Label Dependent Lambda Calculus} and its implementation LDGV.

\section{Label Dependent Lambda Calculus}\label{sec:ldlc}

The LDLC is the foundation of this work. Its main aspect is additional simplicity when using session types. Introducing labels resulted in decouped operations in sending and receiving functions, hence being more lightweight regarding its semantics. See \cite{thiemann2019}. However, session types are not of special relevance when introducing casts. For brevity, we will omit the handling of session types, focusing on labels instead.

A list of language constructs is found in figures~\ref{fig:ldlc-expressions}~to~\ref{fig:ldlc-values}. There is support common functionality like variables \todo{is this the correct word in this context? Is identifier better?} for expressions and types\footnote{
Variable names for expressions have to start with a lowercase letter, e.g. \texttt{\valb x = ()}; for types its an uppercase letter: \texttt{\typeb X : Unit}.}\
, functions and pairs as well as numerical operations and values. In general---as implied by its name---its based on \emph{Simply Typed Lambda Calculus} (details can be found in most introductory literature, e.g. \cite{pierce2002}). As in many functional languages, there is also the unit type $\Unit$ encompassing its only value ``$()$''.

Another two language concepts are more interesting: First and foremost, the support for labels $\ell$ and the recursion over natural numbers using \natrec.

\begin{figure}
\begin{align*}
 M,N,P ::=
    & \enspace x \enspace|\enspace
      () \enspace|\enspace
      \ell \enspace|\enspace
      x \in \mathbb{R} \\
    & |\enspace M \circ N & \circ \in \{+,-,\times,\div\} \\
    & |\enspace \case X \{\overline{\ell : N_\ell}\} & \text{label set elimination} \\
    & |\enspace \natrec M \{ N, x . t . (y : B) . P \} & \mathbb{N}\text{ recursor} \\
    & |\enspace \lambda (x : A).M & \text{abstraction} \\
    & |\enspace M N & \text{application}\\
    & |\enspace \letb x = M \inb N \\
    & |\enspace \letb \langle x, y \rangle = M \inb N \\
    & |\enspace \langle x = M, N \rangle & \text{pair construction}\\
    & |\enspace \fstb M \enspace|\enspace \sndb M & \text{pair elimination}
\end{align*}
\caption{Expressions in LDLC}
\label{fig:ldlc-expressions}
\end{figure}

\begin{figure}
\begin{align*}
 A, B ::=
    & \enspace t \enspace|\enspace
      \Unit
    & |\enspace \Int \enspace|\enspace
      \Nat \enspace|\enspace
      \Double \\
    & |\enspace \{ \ell_1, \dots, \ell_n \} & \text{finite label set} \\
    & |\enspace [x:A,B] \enspace|\enspace [A,B] & \text{pair type} \\
    & |\enspace \{\{ M = N : A \}\} & \text{type equality} \\
    & |\enspace (x:A) \rightarrow B & \text{function type} \\
    & |\enspace \case M \{\overline{\ell : A_\ell}\} \\
    & |\enspace \natrec M \{ A, t.B \}
\end{align*}
\caption{Types in LDLC}
\label{fig:ldlc-types}
\end{figure}

\begin{figure}
\begin{align*}
    V, W ::=
    & \enspace () \enspace|\enspace
      \ell \enspace|\enspace
      x \in \mathbb{R} \\
    & |\enspace \lambda (x:A).M & \text{function value} \\
    & |\enspace \langle V, W \rangle & \text{pair value}
\end{align*}
\caption{Values in LDLC}
\label{fig:ldlc-values}
\end{figure}

\subsection{Labels and Label Sets}

The main feature of LDLC is its use of labels. It evaluates to itself, thus it forms its own value. But what about its type? Any finite non-empty set of labels $L$ is a type. For instance, this is sufficient to declare a boolean type, see equation~\ref{eqn:bool}.

The minimal type is the singleton type of its corresponding label. For label $\ell$ this is $\{\ell\}$. Apart from that there is the bottom type $\bot$ which corresponds to a hypothetical empty label set.

Predominantly, labels appear in context of \case terms. These may occur as expressions or as types and act as eliminator for labels. They provide a mapping from each label of the corresponding label set to an expression or a type. Hence the name of the calculus, \emph{Label Dependent} Lambda Calculus. The type of an expression may depend on a label value.

If one label type $L_1$ is a subset of another label type $L_2$, then $L_1$ is a subtype of $L_2$, i.e. $L_1 <: L_2$. Thus, there is no $L$ that is a subtype of $\bot$. Subtyping in LDLC is closed under transitivity.

\subsection{Recursor over Natural Numbers}

\todo{AbklÃ¤ren woher die beiden Typ-Argumente bei \natrec kommen.}

\section{LDGV Interpreter and Compiler}

LDGV stands for ``Label Dependency'' and ``Gay \& Vasconcelos'', the authors of multiple papers about Session Types, e.g. \cite{gayvasconcelos2010}. In this work's context, it is the name of the interpreter and compiler for LDLC and its extension CCLDLC, written in the Haskell programming language.

Its syntax largely equals the calculus from section~\ref{sec:ldlc}. There are also statements for declarations and assertions, as seen in figure~\ref{fig:ldgv-statements}.
A label is written as combination of alphanumeric characters, prefixed by an apostroph. Translating equation~\ref{eqn:ldlc} to a valid LDGV program results the sample program in figure~\ref{fig:ldgv-program}.

\begin{figure}
\begin{lstlisting}[language=ldgv]
val x = M   -- variable declaration
val x : A   -- variable signature declaration
type t : A  -- type declaration
A <: B      -- subtype assertion
A =: B      -- type equivalence assertion
= x M N     -- WHAT DOES THIS DO?
\end{lstlisting}
\caption{Statements in LDGV}
\label{fig:ldgv-statements}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=ldgv,numbers=left]
type Bool : {'T, 'F}
val not(b: Bool) = (case b {'T: 'F, 'F: 'T})
fn(x: Bool)
        fn(y: case x {'T: Int, 'F: Bool})
              case x {'T: 17+y, 'F: not y}
\end{lstlisting}
\caption{Sample LDGV program}
\label{fig:ldgv-program}
\end{figure}
