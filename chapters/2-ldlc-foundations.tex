\chapter{Foundations}\label{chap:foundations}

Before diving into the \emph{Cast Calculus} we introduce the foundation, the \emph{Label Dependent Lambda Calculus} and its implementation LDGV.

\section{Label Dependent Lambda Calculus}\label{sec:ldlc}

The LDLC is the foundation of this work. Its main aspect is the gain of additional simplicity in context of session types. The introduction of labels results in decouped operations in sending and receiving functions, hence being more lightweight regarding its semantics. See \cite{thiemann2019}. However, session types are not of special relevance when introducing casts. For brevity, we will omit the handling of session types, focusing on labels instead.

A list of language constructs is found in figures~\ref{fig:ldlc-expressions}~to~\ref{fig:ldlc-values}. There is support for common functionality like variables, expressions and types,\footnote{
Variable names for expressions have to start with a lowercase letter, e.g. \texttt{\valb x = ()}; for types its an uppercase letter: \texttt{\typeb X : Unit}.} functions and pairs as well as numerical operations and values. In general---as implied by its name---its based on \emph{Simply Typed Lambda Calculus} (details can be found in most introductory literature, e.g. \cite{pierce2002}). As in many functional languages, there is also the unit type $\Unit$ encompassing its only value ``$()$''.

Another two language concepts are more interesting: First and foremost, the support for labels $\ell$. Labels can habe arbitrary names. A set of distinct labels forms a type. Moreover, there is a recursor over natural numbers $\rec V M x.y.N$. This allows for recursively constructing expressions by using base expression $M$ for $n=0$ and otherwise expression $N$ with appropriate substitutions.

\begin{figure}
\begin{align*}
 M,N,P ::=
    & \enspace x \enspace|\enspace
      () \enspace|\enspace
      \ell \enspace|\enspace
      x \in \mathbb{R} \\
    & |\enspace M \circ N & \circ \in \{+,-,\times,\div\} \\
    & |\enspace \case X \{\overline{\ell : N_\ell}\} & \text{label set elimination} \\
    & |\enspace \rec V~M~x.y.N & \mathbb{N}\text{ recursor} \\
    & |\enspace \lambda (x : A).M & \text{abstraction} \\
    & |\enspace M N & \text{application}\\
    & |\enspace \letb x = M \inb N & \text{bind in $N$}\\
    & |\enspace \letb \langle x, y \rangle = M \inb N & \text{bind pair in $N$} \\
    & |\enspace \langle x = M, N \rangle & \text{pair construction}\\
    & |\enspace \fstb M \enspace|\enspace \sndb M & \text{pair elimination}
\end{align*}
\caption{Expressions in LDLC}
\label{fig:ldlc-expressions}
\end{figure}

\begin{figure}
\begin{align*}
 A, B ::=
    & \enspace t \enspace|\enspace
      \Unit
    \\ &  |\enspace \Int \enspace|\enspace
      \Nat \enspace|\enspace
      \Double \\
    & |\enspace \{ \ell_1, \dots, \ell_n \} & \text{finite label set} \\
    & |\enspace [x:A,B] \enspace|\enspace [A,B] & \text{pair type} \\
    & |\enspace \{\{ M = N : A \}\} & \text{type equality} \\
    & |\enspace (x:A) \rightarrow B & \text{function type} \\
    & |\enspace \case M \{\overline{\ell : A_\ell}\} \\
    & |\enspace \rec V~A~t.B & \text{recursor type}
\end{align*}
\caption{Types in LDLC}
\label{fig:ldlc-types}
\end{figure}

\begin{figure}
\begin{align*}
    V, W ::=
    & \enspace () \enspace|\enspace
      \ell \enspace|\enspace
      x \in \mathbb{R} \\
    & |\enspace (\rho, \lambda (x:A).M) & \text{function value} \\
    & |\enspace \langle V, W \rangle & \text{pair value} \\
    \rho ::= & \enspace \cdot \enspace | \enspace \rho, x = V & \text{environment}
\end{align*}
\caption{Values in LDLC}
\label{fig:ldlc-values}
\end{figure}

\subsection{Labels and Label Sets}

The main feature of LDLC is its use of labels. A label evaluates to itself, thus it forms its own value. But what about its type? Any finite non-empty set of labels $L$ is a type. For instance, this is sufficient to declare a boolean type as seen in equation~\ref{eqn:bool}.

The minimal type is the singleton type of its corresponding label. For label $\ell$ this is $\{\ell\}$. Apart from that there is might be a bottom type $\bot$ which corresponds to a hypothetical empty label set. Neither type $\bot$ nor the empty label set are valid types in LDLC.

Predominantly, labels appear in context of \case terms. These may occur as expressions or as types and act as eliminator for labels. They provide a mapping from each label of the corresponding label set to an expression or a type. Hence the name of the calculus, \emph{Label Dependent} Lambda Calculus. The type of an expression may depend on a label value.

If one label type $L_1$ is a subset of another label type $L_2$, then $L_1$ is a subtype of $L_2$, i.e. $L_1 \subseteq L_2 \Leftrightarrow L_1 \leq L_2$. Thus, there is no $L$ that is a subtype of $\bot$. Subtyping in LDLC is closed under transitivity.

\subsection{Recursor over Natural Numbers}

In addition to label dependency, there is another construct dependency on natural numbers: \rec V~M~x.y.N

Value $V$ must be a natural number value which can also be written recursively using the constructors $Z$ (for zero) and $S(V)$ for the successor of $V$. An encoding for a natural number is given by $\overline{n} = S(\dots S(Z))$. When evaluating a recursor, there is a case differentiation by value $V$.

If $V=Z$ the whole expression is reduced to $M$, discarding its latter term. Otherwise, for $V=S(V')$, the \rec expression is reduced to expression $N$ with the following two substitutions: variable $x$ in $N$ is substituted by $V'$, the precessor of $S(V')$; variable $y$ by $\rec V'~M~x.y.N$, the result of the ``previous'' evaluation of the recursor.

It is similar for type conversion of $\rec V~A~t.B$. For $V=Z$, the resulting type is simply $A$. As for $V=S(V')$, the resulting type is given by $B$ after substituting type identifier $t$ in $B$ with $\rec V'~A~t.B$.

\section{LDGV Interpreter}

LDGV stands for ``Label Dependency'' and ``Gay \& Vasconcelos'', the authors of multiple papers about Session Types, e.g. \cite{gayvasconcelos2010}. In this work's context, it is the name of the interpreter and compiler for LDLC and its extension CCLDLC, written in the Haskell programming language.

Its syntax largely equals the calculus from section~\ref{sec:ldlc}. There are also statements for declarations and assertions, as seen in figure~\ref{lst:ldgv-statements}.
A label is written as combination of alphanumeric characters, prefixed by an apostroph. Translating equation~\ref{eqn:ldlc} into a valid LDGV program results in the sample program in figure~\ref{lst:ldgv-program}.

\begin{lstlisting}[language=ldgv,caption=Statements in LDGV,label=lst:ldgv-statements]
val x = M   -- variable declaration
val x : A   -- variable signature declaration
type t : A  -- type declaration
A <: B      -- subtype assertion
A =: B      -- type equivalence assertion
= x M N     -- WHAT DOES THIS DO?
\end{lstlisting}

\begin{lstlisting}[language=ldgv,numbers=left,caption=Sample LDGV program,label=lst:ldgv-program]
type Bool : {'T, 'F}
val not(b: Bool) = (case b {'T: 'F, 'F: 'T})
fn(x: Bool)
        fn(y: case x {'T: Int, 'F: Bool})
              case x {'T: 17+y, 'F: not y}
\end{lstlisting}
